name: Release â€” main

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: read

jobs:
  # â”€â”€ 1. CI obrigatÃ³rio em main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ci:
    name: CI (Build & Test)
    runs-on: ubuntu-latest

    outputs:
      passed: ${{ steps.result.outputs.passed }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.22"
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Build
        run: go build -v ./...

      - name: Vet
        run: go vet ./...

      - name: Test
        run: go test -v -race ./...

      - name: Mark passed
        id: result
        if: success()
        run: echo "passed=true" >> $GITHUB_OUTPUT

  # â”€â”€ 2. Determina versÃ£o via Gemini (curl + jq, sem Python) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  version:
    name: Determine next version (AI)
    runs-on: ubuntu-latest
    needs: ci
    if: needs.ci.outputs.passed == 'true'

    outputs:
      current_tag: ${{ steps.calc.outputs.current_tag }}
      new_tag:     ${{ steps.calc.outputs.new_tag }}
      new_version: ${{ steps.calc.outputs.new_version }}
      bump:        ${{ steps.calc.outputs.bump }}
      has_commits: ${{ steps.calc.outputs.has_commits }}

    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Calculate version
        id: calc
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # â”€â”€ Tag atual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          echo "current_tag=${CURRENT_TAG}" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Current tag: ${CURRENT_TAG:-none}"

          # â”€â”€ Commits desde a Ãºltima tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          if [ -n "$CURRENT_TAG" ]; then
            COMMITS=$(git log "${CURRENT_TAG}..HEAD" --oneline --no-merges)
          else
            COMMITS=$(git log --oneline --no-merges -50)
          fi

          if [ -z "$(echo "$COMMITS" | tr -d '[:space:]')" ]; then
            echo "âš ï¸ No new commits since last tag â€” skipping release"
            echo "has_commits=false" >> $GITHUB_OUTPUT
            echo "new_tag="          >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_commits=true" >> $GITHUB_OUTPUT
          printf '%s' "$COMMITS" > /tmp/commits.txt
          echo "--- commits ---"
          cat /tmp/commits.txt

          # â”€â”€ Pergunta Ã  IA o tipo de bump â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          BUMP="patch"  # fallback padrÃ£o

          if [ -n "$GEMINI_API_KEY" ]; then
            echo "Asking Gemini for bump type..."

            # Monta prompt em arquivo
            {
              printf 'You are a semantic versioning expert.\n'
              printf 'Current version: %s\n\n' "${CURRENT_TAG:-none}"
              printf 'Analyze these git commits and decide the version bump:\n'
              printf 'MAJOR: any commit with "BREAKING CHANGE", "feat!:" or "fix!:"\n'
              printf 'MINOR: any commit starting with "feat:"\n'
              printf 'PATCH: everything else (fix, chore, docs, refactor, test, perf, ci)\n\n'
              printf 'Commits:\n'
              cat /tmp/commits.txt
              printf '\n\nOutput ONLY one word (lowercase): major, minor, or patch\n'
              printf 'No explanation, no punctuation, nothing else.\n'
            } > /tmp/bump_prompt.txt

            # Serializa prompt para JSON com jq
            PROMPT_JSON=$(jq -Rs '.' /tmp/bump_prompt.txt)

            jq -n \
              --argjson p "$PROMPT_JSON" \
              '{contents:[{parts:[{text:$p}]}],generationConfig:{maxOutputTokens:10,temperature:0}}' \
              > /tmp/bump_payload.json

            HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/bump_response.json \
              -X POST \
              -H "Content-Type: application/json" \
              -d @/tmp/bump_payload.json \
              "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}")

            echo "Gemini HTTP: ${HTTP_CODE}"

            if [ "$HTTP_CODE" = "200" ]; then
              # Extrai, remove espaÃ§os/pontuaÃ§Ã£o, normaliza para lowercase
              AI_BUMP=$(jq -r '.candidates[0].content.parts[0].text // empty' /tmp/bump_response.json \
                        | tr -d '[:space:][:punct:]' | tr '[:upper:]' '[:lower:]')

              case "$AI_BUMP" in
                major|minor|patch) BUMP="$AI_BUMP" ;;
                *) echo "âš ï¸ Unexpected AI response '${AI_BUMP}', defaulting to patch" ;;
              esac
              echo "ðŸ¤– AI bump: ${BUMP}"
            else
              echo "âš ï¸ Gemini HTTP ${HTTP_CODE}, using heuristic fallback"
              jq '.' /tmp/bump_response.json || cat /tmp/bump_response.json
            fi
          fi

          # HeurÃ­stica como fallback quando nÃ£o hÃ¡ chave ou IA falhou
          if [ "$BUMP" = "patch" ] && [ -z "$GEMINI_API_KEY" ]; then
            if grep -qiE "(BREAKING CHANGE|feat!|fix!)" /tmp/commits.txt; then
              BUMP="major"
            elif grep -qiE "^[a-f0-9]+ feat(\([^)]+\))?:" /tmp/commits.txt; then
              BUMP="minor"
            fi
            echo "ðŸ“ Heuristic bump: ${BUMP}"
          fi

          echo "bump=${BUMP}" >> $GITHUB_OUTPUT
          echo "ðŸ”¢ Bump type: ${BUMP}"

          # â”€â”€ Calcula nova versÃ£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          if [ -z "$CURRENT_TAG" ]; then
            NEW_VERSION="0.1.0"
          else
            VERSION="${CURRENT_TAG#v}"
            MAJ=$(echo "$VERSION" | cut -d. -f1)
            MIN=$(echo "$VERSION" | cut -d. -f2)
            PAT=$(echo "$VERSION" | cut -d. -f3)
            MAJ=${MAJ:-0}; MIN=${MIN:-0}; PAT=${PAT:-0}

            case "$BUMP" in
              major) NEW_VERSION="$((MAJ+1)).0.0" ;;
              minor) NEW_VERSION="${MAJ}.$((MIN+1)).0" ;;
              *)     NEW_VERSION="${MAJ}.${MIN}.$((PAT+1))" ;;
            esac
          fi

          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "new_tag=v${NEW_VERSION}"    >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸  New tag: v${NEW_VERSION}"

  # â”€â”€ 3. Gera release notes com Gemini (curl + jq, sem Python) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  release-notes:
    name: Generate release notes (AI)
    runs-on: ubuntu-latest
    needs: version
    if: needs.version.outputs.has_commits == 'true'

    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Generate notes with Gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          CURRENT_TAG:    ${{ needs.version.outputs.current_tag }}
          NEW_TAG:        ${{ needs.version.outputs.new_tag }}
          BUMP:           ${{ needs.version.outputs.bump }}
          REPO:           ${{ github.repository }}
        run: |
          # Commits no-merges desde a Ãºltima tag
          if [ -n "$CURRENT_TAG" ]; then
            COMMITS=$(git log "${CURRENT_TAG}..HEAD" --oneline --no-merges)
            DIFF_STAT=$(git diff "${CURRENT_TAG}..HEAD" --stat --no-color 2>/dev/null | head -40 || echo "")
          else
            COMMITS=$(git log --oneline --no-merges -50)
            DIFF_STAT=""
          fi

          printf '%s' "$COMMITS" > /tmp/commits.txt
          AI_NOTES=""

          if [ -n "$GEMINI_API_KEY" ]; then
            echo "Calling Gemini for release notes..."

            # Prompt completo em arquivo
            {
              printf 'You are a developer writing GitHub release notes for version %s.\n' "$NEW_TAG"
              printf 'Previous version: %s\n' "${CURRENT_TAG:-none}"
              printf 'Version bump type: %s\n\n' "$BUMP"
              printf 'Generate professional release notes in markdown with this structure:\n\n'
              printf '# %s\n\n' "$NEW_TAG"
              printf '[One paragraph summarizing what this release brings to users]\n\n'
              printf '## ðŸš€ New Features\n'
              printf '[bullet list â€” omit section if none]\n\n'
              printf '## ðŸ› Bug Fixes\n'
              printf '[bullet list â€” omit section if none]\n\n'
              printf '## â™»ï¸ Refactoring & Improvements\n'
              printf '[bullet list â€” omit section if none]\n\n'
              printf '## ðŸ”§ Internal Changes\n'
              printf '[CI, docs, chore, test â€” omit section if none]\n\n'
              printf '## âš ï¸ Breaking Changes\n'
              printf '[ONLY if there are breaking changes â€” omit section if none]\n\n'
              printf '## ðŸ“¦ Installation\n\n'
              printf '### Quick install\n'
              printf '```bash\n'
              printf 'curl -fsSL https://raw.githubusercontent.com/%s/main/scripts/install.sh | bash\n' "$REPO"
              printf '```\n\n'
              printf '### Manual download\n'
              printf 'Download the binary for your platform from the assets below.\n\n'
              printf '---\n'
              printf '**Full changelog:** [%s...%s](https://github.com/%s/compare/%s...%s)\n\n' \
                "${CURRENT_TAG:-initial}" "$NEW_TAG" "$REPO" "${CURRENT_TAG:-initial}" "$NEW_TAG"
              printf 'Rules:\n'
              printf 'Be concise and user-friendly â€” not just commit hash dumps\n'
              printf 'Explain WHAT changed and WHY it matters to users\n'
              printf 'Group related changes\n'
              printf 'Output ONLY the markdown, no preamble\n\n'
              printf 'Commits:\n'
              cat /tmp/commits.txt
              if [ -n "$DIFF_STAT" ]; then
                printf '\n\nChanged files summary:\n%s\n' "$DIFF_STAT"
              fi
            } > /tmp/notes_prompt.txt

            PROMPT_JSON=$(jq -Rs '.' /tmp/notes_prompt.txt)

            jq -n \
              --argjson p "$PROMPT_JSON" \
              '{contents:[{parts:[{text:$p}]}],generationConfig:{maxOutputTokens:2048,temperature:0.4}}' \
              > /tmp/notes_payload.json

            HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/notes_response.json \
              -X POST \
              -H "Content-Type: application/json" \
              -d @/tmp/notes_payload.json \
              "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}")

            echo "Gemini HTTP: ${HTTP_CODE}"

            if [ "$HTTP_CODE" = "200" ]; then
              AI_NOTES=$(jq -r '.candidates[0].content.parts[0].text // empty' /tmp/notes_response.json)
              [ -n "$AI_NOTES" ] && echo "âœ… Release notes generated" || echo "âš ï¸ Empty response"
            else
              echo "âš ï¸ Gemini HTTP ${HTTP_CODE}:"
              jq '.' /tmp/notes_response.json || cat /tmp/notes_response.json
            fi
          fi

          # Fallback simples sem IA
          if [ -z "$AI_NOTES" ]; then
            AI_NOTES=$(printf '# %s\n\nAutomated release from `main`.\n\n## What'\''s Changed\n\n```\n%s\n```\n\n## ðŸ“¦ Installation\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/%s/main/scripts/install.sh | bash\n```\n\n---\n**Full changelog:** https://github.com/%s/compare/%s...%s' \
              "$NEW_TAG" "$COMMITS" "$REPO" "$REPO" "${CURRENT_TAG:-initial}" "$NEW_TAG")
          fi

          printf '%s\n' "$AI_NOTES" > release_notes.md

          echo "--- preview ---"
          head -30 release_notes.md

      - name: Upload release notes
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes.md
          retention-days: 1

  # â”€â”€ 4. Build multiplataforma (matrix paralela) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build-binaries:
    name: Build ${{ matrix.goos }}/${{ matrix.goarch }}
    runs-on: ubuntu-latest
    needs: version
    if: needs.version.outputs.has_commits == 'true'

    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.22"
          cache: true

      - name: Build & package
        env:
          GOOS:   ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          VERSION="${{ needs.version.outputs.new_version }}"
          COMMIT="${{ github.sha }}"
          LDFLAGS="-X github.com/seu-usuario/commitai/cmd.Version=${VERSION} \
                   -X github.com/seu-usuario/commitai/cmd.Commit=${COMMIT:0:8} \
                   -s -w"
          NAME="commitai_${GOOS}_${GOARCH}"

          mkdir -p dist
          go build -ldflags="$LDFLAGS" -o "dist/${NAME}" .

          cd dist
          tar -czf "${NAME}.tar.gz" "${NAME}"
          sha256sum "${NAME}.tar.gz" > "${NAME}.tar.gz.sha256"
          cd ..

          echo "âœ… dist/${NAME}.tar.gz"
          ls -lh dist/

      - name: Upload binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/
          retention-days: 1

  # â”€â”€ 5. Cria tag Git + GitHub Release â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  publish-release:
    name: Publish GitHub Release
    runs-on: ubuntu-latest
    needs: [version, release-notes, build-binaries]
    if: needs.version.outputs.has_commits == 'true'

    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: /tmp/artifacts/

      - name: Download all binaries
        uses: actions/download-artifact@v4
        with:
          pattern: binary-*
          path: /tmp/artifacts/
          merge-multiple: true

      - name: List artifacts
        run: ls -lhR /tmp/artifacts/

      - name: Create annotated git tag
        run: |
          NEW_TAG="${{ needs.version.outputs.new_tag }}"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag -a "${NEW_TAG}" \
            -m "Release ${NEW_TAG}" \
            -m "$(cat /tmp/artifacts/release_notes.md)"

          git push origin "${NEW_TAG}"
          echo "âœ… Tag ${NEW_TAG} pushed"

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name:    ${{ needs.version.outputs.new_tag }}
          name:        "Release ${{ needs.version.outputs.new_tag }}"
          body_path:   /tmp/artifacts/release_notes.md
          draft:       false
          prerelease:  false
          make_latest: true
          files: |
            /tmp/artifacts/commitai_linux_amd64.tar.gz
            /tmp/artifacts/commitai_linux_amd64.tar.gz.sha256
            /tmp/artifacts/commitai_linux_arm64.tar.gz
            /tmp/artifacts/commitai_linux_arm64.tar.gz.sha256
            /tmp/artifacts/commitai_darwin_amd64.tar.gz
            /tmp/artifacts/commitai_darwin_amd64.tar.gz.sha256
            /tmp/artifacts/commitai_darwin_arm64.tar.gz
            /tmp/artifacts/commitai_darwin_arm64.tar.gz.sha256

      - name: Job summary
        env:
          NEW_TAG: ${{ needs.version.outputs.new_tag }}
          BUMP:    ${{ needs.version.outputs.bump }}
          REPO:    ${{ github.repository }}
        run: |
          echo "## ðŸš€ Release ${NEW_TAG} publicada!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Campo | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| VersÃ£o | \`${NEW_TAG}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Bump | \`${BUMP}\` (IA) |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Release | [Ver](https://github.com/${REPO}/releases/tag/${NEW_TAG}) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Plataformas:** linux/amd64 Â· linux/arm64 Â· darwin/amd64 Â· darwin/arm64" >> $GITHUB_STEP_SUMMARY